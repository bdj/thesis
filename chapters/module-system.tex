\chapter{The Racket Module and Macro Systems}
\label{chap:module-system}

Demodularization is made to run on a program written in a language that combines macros and modules.
For this research, we chose to implement demodularization for the Racket programming language because of its advanced macro and module systems.
This chapter gives background information on Racket through a detailed example program that demonstrates macro and module usage.

% DONE: rewrite this section
\section{The Racket Programming Language}
The Racket Programming Language is a platform for creating powerful abstractions.
These abstractions are created through the use of Racket's macro and module systems. 
The macro system, a heritage from LISP~\cite{LISP} and Scheme~\cite{scheme}, allows programmers to add new features to their programs in an integrated way.
The module system allows programmers to separate their programs into logical parts and hide implementation details. 
Together, they allow programmers to create Languages as Libraries~\cite{lal} that are suitable for specific tasks.

% TODO: mention that programs can extend themselves in the same file
\section{Macros}
Macros are the main way programmers add new features to Racket. 
Macros are written alongside normal functions in a program, but they are used during the compilation of the program. 
Essentially, macros are functions (known as transformers) whose domain and range are syntax objects.
Syntax objects are data structures that contain the raw syntax of a program, along with lexical information and other properties associated with the syntax.
If a programmer needs the power, they can write transformers using all of the features of Racket, as long as the function takes in and produces syntax objects.
Racket provides pattern-matching for syntax objects that makes writing macros simpler when that is all that a programmer needs.

The \racket{define-syntax} form is used to identify a macro definition that is a function from syntax to syntax.
The helper function, \racket{syntax-case} matches syntax patterns so that it is easy to use them in the output of the macro.

% DONE: example should use a function or letrec, not let loop
% DONE: maybe just use syntax-case here
\begin{listing}[tb]
  \inputminted{racket}{listings/while-macro.rkt}
  \caption{a macro implementation of a \racket{while} loop}
  \label{lst:while-macro.rkt}
\end{listing}
Listing~\ref{lst:while-macro.rkt} shows how to use one of these macros to write a \racket{while} loop. 
The macro turns a \racket{while} loop into a recursive function and a call to that recursive function.
Whatever syntax used by the programmer for the \racket{test} and \racket{body ...} forms will be substituted by \racket{syntax-case} into the output of the macro. 
Listing~\ref{lst:while-expanded.rkt} shows a use of the while macro and what it expands into after running the macro. 
\begin{listing}[tb]
  \inputminted{racket}{listings/while-expanded.rkt}
  \caption{use and expansion of a \racket{while} loop}
  \label{lst:while-expanded.rkt}
\end{listing}
% DONE: example expansion
% DONE: fuller explanation of hygeine with citation
Racket's macros are hygienic \cite{hygiene}, which means that identifiers created from programs will not clash with identifiers created from macros. 
This means that macros are protected from the surrounding program changing their identifiers, and also that the program is protected from the macro changing its identifiers.
In this example that means that the Racket program using a while loop will not be able to call the \racket{while-loop} function that the macro creates, and that if the program has another definition for \racket{while-loop}, it will be independent from the definition introduced by the macro.
Also, each use of the macro will have distinct definitions for \racket{while-loop} so that the macro can be nested and used multiple times.
\section{Modules}
% TODO: all listings are modules in separate files
Racket modules are a way of grouping definitions, expressions, and macros. 
Modules also allow control over imports and exports, using the Racket forms \racket{require} and \racket{provide} respectively.
Listing~\ref{lst:counter.rkt} shows a simple Racket module and some of the features of the Racket module system.
\begin{listing}[tb]
  \inputminted{racket}{listings/counter.rkt}
  \caption{\texttt{counter.rkt}: A simple Racket module implementing a counter}
  \label{lst:counter.rkt}
\end{listing}
The \texttt{counter} module contains a variable definition and functions for getting and incrementing that variable.
The module only exports the functions, so the module encapsulates the variable.
If a programmer wanted to use this module, they would import it using \racket{require} as shown in Listing~\ref{lst:while-test.rkt}. 

\begin{listing}[tb]
  \inputminted{racket}{listings/while-test.rkt}
  \caption{\texttt{while-test.rkt}: A Racket module that uses other modules}
  \label{lst:while-test.rkt}
\end{listing}

It is also possible to use modules to help write macros.
For example, if a programmer wanted to change the \racket{while} macro so that it reported how many expressions were in each while loop, they could use the \texttt{counter} module inside the \racket{while} definition as seen in Listing~\ref{lst:while-lang.rkt}.
\begin{listing}[tb]
  \inputminted{racket}{listings/while-lang.rkt}
  \caption{\texttt{while-lang.rkt}: A Racket module implementing a language with \racket{while} loops}
  \label{lst:while-lang.rkt}
\end{listing}
It is possible to add code to the \racket{while} macro because it is just a function from syntax to syntax that runs at compile-time. 
Also, the \racket{require} form includes a \racket{for-syntax} form to indicate that the \texttt{counter} module is needed at compile-time (along with the \racket{racket/base} module for \racket{printf}).
Now this module can be used to extend the language of other programs by adding a \racket{while} loop, although it is just a library that is included like any other library.

\section{Languages}
% TODO: Rewrite this section, it sucks
The ability to use modules as languages allows programmers to write specialized domain-specific languages (DSLs) to better express solutions to domain problems. 
% TODO: akward sentence
Using this ability, programmers have added languages for Typed Racket~\cite{typed}, Object-Oriented Racket~\cite{oo}, Logic Programming~\cite{logic}, and more.
Also, because they are modules, it is possible to use them all in the same program and use the right language for each specific problem.
The language creating facilities of Racket extend to more than just collections of functions and macros; they also allow changing the parser and changing the meaning of things like function application syntax. 

\section{Separate Compilation}
In the presence of macros that can run arbitrary code, compilation of a single module becomes complicated. 
Compilation and execution of code has to be interleaved in order to produce the correct compiled program.
% DONE: explain that listings form a program with multiple modules and while-test is main
% DONE: include module dependency figure
All of the listings in the previous section form a program with the \racket{while-test} module as the main module.
Figure~\ref{fig:modules.tex} shows the relationship between the different modules in the program.
\begin{figure}
  \input{figures/modules.tex}
  \caption{Module dependencies for the \racket{while-test} program}
  \label{fig:modules.tex}
\end{figure}
To compile the program, both the \racket{while-lang} and \racket{counter} need to be compiled before \racket{while-test}, but also the \racket{counter} module needs to be compiled and ready to use while compiling \racket{while-test} because the counter functions are used inside the \racket{while} macro.
While compiling \racket{while-test}, the \racket{while} macro will be expanded and code from the \racket{counter} module will run.
The value of the counter is not shared between compiling \racket{while-test} and running it.

\section{Phases}
The way the Racket module system allows for reliable separate compilation is by separating compilation and execution into phases.
Phase 0 is the execution phase of the main module of a program, what could be considered running the program.
Phase 1 is the compilation phase of the main module, which could include execution of code inside macros. 
A module can contain both phase 0 and phase 1 code; regular function definitions are phase 0, and macro definitions are phase 1.

Higher phases occur when macros use other macros in their implementation.
Another way higher phases occur is by importing modules for use inside a macro.
In the example program, the \racket{while-lang} module imports the \racket{counter} module using \racket{for-syntax}.
The \racket{for-syntax} form means that the module will be included for use at phase 1 relative to the including module, so that its code is available to use inside macro definitions.
There is an analogous form, \racket{for-template}, that will include code at phase -1 relative to the including module, so that the included module's code will be available for use inside the output of a macro. 
By allowing references to relative phases going in both directions, a Racket program can have a complex structure of imports and exports.

It is possible for a single module to be used in multiple phases, and each phase will have a separate instantiation of the module.
In the example program above, the \racket{counter} module will be instantiated twice, once for use while macros are running at phase 1, and once for use while the main program is running at phase 0.

Even though compilation of a program can go through many phases and interleave compiling and running code many times, side effects that occur during this process are discarded. 
The separate compilation guarantee of the Racket module system is that ``Any effects of the instantiation of the module's phase 1 due to compilation on the Racket runtime system are discarded'' \cite{sep}. 

\section{Program Evaluation}
Running a separately compiled Racket program involves following all of the \racket{require} forms and running all phase 0 code in the order in which the code is imported.
It is possible that there will be phase 0 code to run from an imported module where the import path to that module includes phase shifts.
Module phases are relative to one another, so if one module imports a module at phase 1, which then imports a different module at phase -1, the code in the third module will be at phase 0 relative to the first module and must be run in the final program.

By understanding how Racket programs are compiled and evaluated, it is apparent that only phase 0 code is necessary to run the program. 
This is the basis for how demodularization can recover whole programs from separately compiled Racket modules. 
