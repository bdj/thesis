\chapter{The Racket Module System}
Modules are the basic building block of programs written in Racket.
A Racket module specifies the language it is written in, definitions, expressions (run for their effect), and imports and exports. 
Modules usually correspond to files, but multiple modules can be defined in a single file through the use of submodules.
A module's language controls all aspects of what the module means, from how it is parsed to what it means to do function application. 
Usually the language definition is just another Racket module. 
Racket definitions can be normal runtime definitions or compile-time definitions.
The Racket compiler separates compile-time and runtime definitions into different phases, with compile-time definitions at phase 1 and runtime definitions at phase 0.
Macros are special definitions with phase 0 bindings, but with phase 1 values. 
Macros allow programmers to add new features to their programs that can't be added through normal function definitions. 
Racket also allows for definitions directly at phase 1 so that programmers can write helper code for macros through \racket{begin-for-syntax}.

Imports in Racket use the \racket{require} form, which allows for importing definitions from other modules in a variety of ways. 
\racket{require} lets the programmer specify which identifiers to import and any renamings to use.
Also, the programmer can specify at what phase to import another module so they can use other modules to help write macros.
Exports in Racket use the \racket{provide} form, which has similar features as \racket{require}, such as control over which identifiers are exported, renaming capabilities, and phase shifting capabilities.

The following example illustrates some of the features of the racket module system. 

\begin{listing}
  \inputminted{racket}{listings/obj.rkt}
  \caption{A caption}
  \label{lst:obj.rkt}
\end{listing}

Listing~\ref{lst:obj.rkt} shows the \texttt{obj} module.
The \texttt{obj} module contains a variable definition, and an accessor and mutator function.
The module only exports the functions, so there is no way to access or mutate the variable without using the functions.

\begin{listing}
  \inputminted{racket}{listings/while-test.rkt}
  \caption{Another caption}
  \label{lst:while-test.rkt}
\end{listing}

Listing~\ref{lst:while-test.rkt} shows the \texttt{while-test} module.
This module shows two ways to use other modules in Racket.
First, it uses the \texttt{while-lang} module as the language in which the module is written.
Second, it imports the \texttt{obj} module while adding a prefix to everything the \texttt{obj} module exports. 
Because the \texttt{while-test} module is written in the \texttt{while-lang} language, it has access to a definition for a \racket{while} loop.

\begin{listing}
  \inputminted{racket}{listings/while-lang.rkt}
  \caption{Third Caption}
  \label{lst:while-lang.rkt}
\end{listing}

Listing~\ref{lst:while-lang.rkt} shows the \texttt{while-lang} module.
The \racket{require} form has two parts, one that imports using \racket{for-syntax}, and one that is a runtime \racket{require}.
The \racket{for-syntax} imports are available to use at compile-time. 
We need the import of \racket{racket/base} so that we can use \racket{printf} at compile-time.
The import of \racket{"obj.rkt"} is so that we can use the functions from the \texttt{obj} module at compile-time as well.
The runtime \racket{require} of \racket{"obj.rkt"} is so that we can use \racket{set-val!} at runtime to show the idea of phase separation.

The \racket{provide} form has three parts in this module that all show different features of the module system.
The first export uses a combination of \racket{all-from-out} and \racket{except-out} to provide everthing defined in the \racket{racket/base} language except for \mintinline{racket}{#%module-begin}.
This allows every program written in the \racket{while-lang} language to have access to (almost) everything in the \racket{racket/base} language.
The next export provides \mintinline{racket}{#%module-begin} by renaming the \racket{module-begin} macro written in the module.
The final export is a macro for writing while loops.

The \mintinline{racket}{#%module-begin} macro is a special hook that gets added around racket programs so that a programmer can add things that happen to every program written in their language.
In this case, we add a \racket{printf} before the rest of the code in a \racket{while-lang} program.
Next is the definition of a while loop as a macro that transforms into a combination of a \racket{loop} and an \racket{if}. 
After that, the module contains some runtime code using the \texttt{obj} module.
Finally, the module contains a \racket{begin-for-syntax} expression. 
All of the code written inside a \racket{begin-for-syntax} expression is shifted to phase 1 (compile-time).
Therefore, the \racket{(set-val! 2)} and \racket{(printf ....)} expressions will run when the module is compiled. 

The final output of compiling and running the program is shown in Listing~\ref{lst:output.tex}. 
We first compile \texttt{while-lang.rkt} and the compile-time code runs and the output shows that only compile-time code ran.
Next, we compile \texttt{while-test.rkt} and once again the compile-time code from \texttt{while-lang.rkt} runs because it is imported.
Following that, we run the program and the output shows that the runtime values are not related to the compile-time values, but the runtime values are shared across modules.

\begin{listing}
  \centering
  \input{listings/output}
  \caption{Output of compiling and running while-test}
  \label{lst:output.tex}
\end{listing}

The output also informs us of the order things happen in when modules are compiled and run. 
Figure~\ref{fig:modules} shows how the modules in this program are related.
Compilation happens by visiting all the required modules and running any phase 1 code (which also means the phase 1 code has to be compiled at phase 2, and so on). 
Evaluation happens by visiting all the required modules and running the phase 0 code, which in this case means we see the runtime output from \texttt{while-lang} before the runtime output of \texttt{while-test}.

\begin{figure}
  \centering
  \input{figures/modules}
  \caption{module stuff}
  \label{fig:modules}
\end{figure}

By understanding how Racket programs are compiled and evaluated, we can see that only phase 0 code is necessary to run the program. 
This is the basis for how demodularization can recover whole programs from separately compiled Racket modules. 
