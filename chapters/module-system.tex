\chapter{The Racket Module System}

\section{The Racket Programming Language}
The Racket Programming Language is descended from LISP~\ref{} and Scheme~\ref{}.
Therefore, Racket's syntax is based on s-expressions (although it is possible to change this).
Racket provides many language features, such as closures, first-class continuations, macros, contracts, and garbage collection.
The main implementation of Racket is a virtual machine with Just-In-Time compilation. 
The real power of Racket comes from the idea of Languages as Libraries~\ref{}, where a programmer adds features to the language by writing Racket code that extends the compiler.

\section{Macros}
Macros are the main way programmers add new features to Racket. 
Esentially, macros are functions (known as transformers) whose domain and range are syntax objects.
Syntax objects are data structures that contain the raw syntax of a program, along with lexical information and other properties associated with the syntax.
If a programmer needs the power, they can write transformers using all of the features of Racket, as long as the function takes in and produces syntax objects.
Racket provides pattern-matching for syntax objects that makes writing macros simpler when that is all that a programmer needs.

The simplest way to write a macro is to use \racket{define-syntax-rule}.
\racket{define-syntax-rule} has two arguments, the first is a pattern of syntax to match and the second is what that syntax should transform into.
\begin{listing}
  \inputminted{racket}{listings/while-macro.rkt}
  \caption{A macro implementation of a \racket{while} loop}
  \label{lst:while-macro.rkt}
\end{listing}
Listing~\ref{lst:while-macro.rkt} shows how to use one of these macros to write a \racket{while} loop. 
The first argument models what a while loop will look like in use, which will be a \racket{while} identifier, followed by a \racket{test} expression that will be tested each time through the loop, followed by zero or more expressions to run in the body of the while loop.
This transforms into a \racket{let} combined with an \racket{if}, with whatever syntax the programmer put in for \racket{test} and \racket{body ...} being substituted into the output.
Racket's macros are hygenic, which in this case means that even if the code passed in as the body contains a \racket{loop} variable, it will not clash with the value from the macro.

\section{Modules}
% TODO: all listings are modules in separate files
Racket modules are a way of grouping definitions, expressions, and macros into groups. 
Modules also allow control over imports and exports, using the racket forms \racket{require} and \racket{provide} respectively.
Listing~\ref{lst:counter.rkt} shows a simple Racket module and some of the features of the Racket module system.
\begin{listing}
  \inputminted{racket}{listings/counter.rkt}
  \caption{\texttt{counter.rkt}: A simple Racket module implementing a counter}
  \label{lst:counter.rkt}
\end{listing}
The \texttt{counter} module contains a variable definition and functions for getting and incrementing that variable.
The module only exports the functions, so the module encapsulates the variable.
If a programmer wanted to use this module, they would import it using \racket{require} as shown in Listing~\ref{lst:while-test.rkt}. 

\begin{listing}
  \inputminted{racket}{listings/while-test.rkt}
  \caption{\texttt{while-test.rkt}: A Racket module that uses other modules}
  \label{lst:while-test.rkt}
\end{listing}

It is also possible to use modules to help write macros.
For example, if a programmer wanted to change the \racket{while} macro so that it reported how many expressions were in each while loop, they could use the \texttt{counter} module inside the \racket{while} definition as seen in Listing~\ref{lst:while-lang.rkt}.
\begin{listing}
  \inputminted{racket}{listings/while-lang.rkt}
  \caption{\texttt{while-lang.rkt}: A Racket module implementing a language with \racket{while} loops}
  \label{lst:while-lang.rkt}
\end{listing}
The \racket{while} macro has to change to use \racket{syntax-case} so that it is possible to run arbitrary code alongside the pattern-matching functionality.
Also, the \racket{require} form includes a \racket{for-syntax} form to indicate that the \texttt{counter} module is needed at compile-time (along with the \racket{racket/base} module for \racket{printf}).
% TODO: show don't tell for interesting
The \texttt{while-lang} module also has an interesting \racket{provide} form that exports everything from \racket{racket/base}.
This export allows programmers to use the \texttt{while-lang} module as a language for other modules, like was done in the \texttt{while-test} module.

\section{Languages}
% TODO: Rewrite this section, it sucks
The ability to use modules as languages allows programmers to write specialized domain-specific languages (DSLs) to better express solutions to domain problems. 
% TODO: akward sentence
Using this ability, programmers have added languages for Typed Racket~\ref{}, Object-Oriented Racket~\ref{}, Logic Programming~\ref{}, and more~\ref{}.
Also, because they are modules, it is possible to use them all in the same program and use the right language for each specific problem.
The language creating facilities of Racket extend to more than just collections of functions and macros; they also allow changing the parser and changing the meaning of things like function application. 

\section{Separate Compiliation}
In the presence of macros that can run arbitrary code, compilation of a single module becomes complicated. 
Compilation and execution of code has to be interleaved in order to produce the correct compiled program.
% TODO: explain that listings form a program with multiple modules and while-test is main
% TODO: run on sentence
% TODO: include module dependency figure
In the program with the main module \racket{while-test} above, both the \racket{while-lang} and \racket{counter} need to be compiled before \racket{while-test}, but also the \racket{counter} module needs to be compiled and ready to use while compiling \racket{while-test} because the counter functions are used inside the \racket{while} macro.
While compiling \racket{while-test}, the \racket{while} macro will be expanded and code from the \racket{counter} module will run.
The value of the counter should not be shared between compiling \racket{while-test} and running it.

\section{Phases}
The way the Racket module system allows for reliable separate compiliation is by separating compilation and execution into phases.
Phase 0 is the execution phase of the main module of a program, what could be considered running the program.
Phase 1 is the compilation phase of the main module, which could include execution of code inside macros. 
Phase 2 is the compiliation phase of any modules that need to execute during phase 1, and higher phases are used as needed to compile and run code used in lower phases.
% TODO: awkward sentence
It is possible for modules to reference modules at higher phases by using the \racket{for-syntax} form as seen above, and it is also possible to reference modules at lower phases by using the \racket{for-template} form.

In the example above, the \racket{while-test} module is compiled at phase 1, which triggers compilation of the \racket{counter} module at phase 2, so that the \racket{counter} module can be instantiated at phase 1 to count how many expressions are in the \racket{while} loop.
The phase 1 instantiation of the \racket{counter} module is separate from the phase 0 instantiation of the module.
This is a guarantee of the Racket module system, that ``Any effects of the instantiation of the module's phase 1 due to compilation on the Racket runtime system are discarded,'' which is known as the "Separate Compilation Guarantee"~\ref{}.

\section{Program Evaluation}
Running a separately compiled Racket program involves following all of the \racket{require} forms and running all phase 0 code in the order they were imported.
It is possible that phase 0 code will come through a module that is required by using \racket{for-syntax} if somewhere along the line code is then required using \racket{for-template}.

% TODO: we can see huh
By understanding how Racket programs are compiled and evaluated, we can see that only phase 0 code is necessary to run the program. 
This is the basis for how demodularization can recover whole programs from separately compiled Racket modules. 
