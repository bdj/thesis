\chapter{The Racket Module System}
\label{chap:module-system}

% DONE: rewrite this section
\section{The Racket Programming Language}
The Racket Programming Language is a platform for creating powerful abstractions.
These abstractions are created through the use of Racket's macro and module systems. 
The macro system, a heritage from LISP~\cite{LISP} and Scheme~\cite{scheme}, allows programmers to add new features to their programs in an integrated way.
The module system allows programmers to separate their programs into logical parts and hide implementation details. 
Together, they allow programmers to create Languages as Libraries~\cite{lal} that are suitable for specific tasks.

% TODO: mention that programs can extend themselves in the same file
\section{Macros}
Macros are the main way programmers add new features to Racket. 
Macros are written alongside normal functions in a program, but they are used during the compilation of the program. 
Esentially, macros are functions (known as transformers) whose domain and range are syntax objects.
Syntax objects are data structures that contain the raw syntax of a program, along with lexical information and other properties associated with the syntax.
If a programmer needs the power, they can write transformers using all of the features of Racket, as long as the function takes in and produces syntax objects.
Racket provides pattern-matching for syntax objects that makes writing macros simpler when that is all that a programmer needs.

The \racket{define-syntax} form is used to identify a macro definition that is a funtion from syntax to syntax.
The helper function, \racket{syntax-case} matches syntax patterns so that it is easy to use them in the output of the macro.

% DONE: example should use a function or letrec, not let loop
% DONE: maybe just use syntax-case here
\begin{listing}
  \inputminted{racket}{listings/while-macro.rkt}
  \caption{a macro implementation of a \racket{while} loop}
  \label{lst:while-macro.rkt}
\end{listing}
Listing~\ref{lst:while-macro.rkt} shows how to use one of these macros to write a \racket{while} loop. 
The macro turns a \racket{while} loop into a recursive function and a call to that recursive function.
Whatever syntax used by the programmer for the \racket{test} and \racket{body ...} forms will be substituted by \racket{syntax-case} into the output of the macro. 
Listing~\ref{lst:while-expanded.rkt} shows a use of the while macro and what it expands into after running the macro. 
\begin{listing}
  \inputminted{racket}{listings/while-expanded.rkt}
  \caption{use and expansion of a \racket{while} loop}
  \label{lst:while-expanded.rkt}
\end{listing}
% DONE: example expansion
% DONE: fuller explanation of hygeine with citation
Racket's macros are hygienic \cite{hygiene}, which means that identifiers created from programs will not clash with identifiers created from macros. 
This means that macros are protected from the surrounding program changing their identifiers, and also that the program is protected from the macro changing its identifiers.
In this example that means that the Racket program using a while loop will not be able to call the \racket{while-loop} function that the macro creates, and that if the program has another definition for \racket{while-loop}, it will be independent from the definition introduced by the macro.
Also, each use of the macro will have distinct definitions for \racket{while-loop} so that the macro can be nested and used multiple times.
\section{Modules}
% TODO: all listings are modules in separate files
Racket modules are a way of grouping definitions, expressions, and macros. 
Modules also allow control over imports and exports, using the Racket forms \racket{require} and \racket{provide} respectively.
Listing~\ref{lst:counter.rkt} shows a simple Racket module and some of the features of the Racket module system.
\begin{listing}
  \inputminted{racket}{listings/counter.rkt}
  \caption{\texttt{counter.rkt}: A simple Racket module implementing a counter}
  \label{lst:counter.rkt}
\end{listing}
The \texttt{counter} module contains a variable definition and functions for getting and incrementing that variable.
The module only exports the functions, so the module encapsulates the variable.
If a programmer wanted to use this module, they would import it using \racket{require} as shown in Listing~\ref{lst:while-test.rkt}. 

\begin{listing}
  \inputminted{racket}{listings/while-test.rkt}
  \caption{\texttt{while-test.rkt}: A Racket module that uses other modules}
  \label{lst:while-test.rkt}
\end{listing}

It is also possible to use modules to help write macros.
For example, if a programmer wanted to change the \racket{while} macro so that it reported how many expressions were in each while loop, they could use the \texttt{counter} module inside the \racket{while} definition as seen in Listing~\ref{lst:while-lang.rkt}.
\begin{listing}
  \inputminted{racket}{listings/while-lang.rkt}
  \caption{\texttt{while-lang.rkt}: A Racket module implementing a language with \racket{while} loops}
  \label{lst:while-lang.rkt}
\end{listing}
It is possible to add code to the \racket{while} macro because it is just a function from syntax to syntax that runs at compile-time. 
Also, the \racket{require} form includes a \racket{for-syntax} form to indicate that the \texttt{counter} module is needed at compile-time (along with the \racket{racket/base} module for \racket{printf}).
Now this module can be used to extend the language of other programs by adding a \racket{while} loop, although it is just a library that is included like any other library.

\section{Languages}
% TODO: Rewrite this section, it sucks
The ability to use modules as languages allows programmers to write specialized domain-specific languages (DSLs) to better express solutions to domain problems. 
% TODO: akward sentence
Using this ability, programmers have added languages for Typed Racket~\cite{typed}, Object-Oriented Racket~\cite{oo}, Logic Programming~\cite{logic}, and more.
Also, because they are modules, it is possible to use them all in the same program and use the right language for each specific problem.
The language creating facilities of Racket extend to more than just collections of functions and macros; they also allow changing the parser and changing the meaning of things like function application syntax. 

\section{Separate Compiliation}
In the presence of macros that can run arbitrary code, compilation of a single module becomes complicated. 
Compilation and execution of code has to be interleaved in order to produce the correct compiled program.
% DONE: explain that listings form a program with multiple modules and while-test is main
% DONE: include module dependency figure
All of the listings in the previous section form a program with the \racket{while-test} module as the main module.
Figure~\ref{fig:modules.tex} shows the relationship between the different modules in the program.
\begin{figure}
  \input{figures/modules.tex}
  \caption{Module dependencies for the \racket{while-test} program}
  \label{fig:modules.tex}
\end{figure}
To compile the program, both the \racket{while-lang} and \racket{counter} need to be compiled before \racket{while-test}, but also the \racket{counter} module needs to be compiled and ready to use while compiling \racket{while-test} because the counter functions are used inside the \racket{while} macro.
While compiling \racket{while-test}, the \racket{while} macro will be expanded and code from the \racket{counter} module will run.
The value of the counter is not shared between compiling \racket{while-test} and running it.

\section{Phases}
The way the Racket module system allows for reliable separate compiliation is by separating compilation and execution into phases.
Phase 0 is the execution phase of the main module of a program, what could be considered running the program.
Phase 1 is the compilation phase of the main module, which could include execution of code inside macros. 
Phase 2 is the compiliation phase of any modules that need to execute during phase 1, and higher phases are used as needed to compile and run code used in lower phases.
It is possible for a single module to be used in multiple phases.
Each phase will have a separate instantiation of the module.
% TODO: awkward sentence
% TODO: maybe explain for-template better (first time introduced)
It is possible for modules to reference modules at higher phases by using the \racket{for-syntax} form as seen above, and it is also possible to reference modules at lower phases by using the \racket{for-template} form.
The \racket{for-template} form is used when a programmer wants to include code from an imported module in the output of a macro.

In the example above, the \racket{while-test} module is compiled at phase 1, which triggers compilation of the \racket{counter} module at phase 2, so that the \racket{counter} module can be instantiated at phase 1 to count how many expressions are in the \racket{while} loop.
The phase 1 instantiation of the \racket{counter} module is separate from the phase 0 instantiation of the module.
The separate compilation guarantee of the Racket module system is that ``Any effects of the instantiation of the module's phase 1 due to compilation on the Racket runtime system are discarded'' \cite{sep}. 

\section{Program Evaluation}
Running a separately compiled Racket program involves following all of the \racket{require} forms and running all phase 0 code in the order in which the code is imported.
It is possible that phase 0 code will come through a module that is required by using \racket{for-syntax} if somewhere along the line code is then required using \racket{for-template}.

By understanding how Racket programs are compiled and evaluated, it is apparent that only phase 0 code is necessary to run the program. 
This is the basis for how demodularization can recover whole programs from separately compiled Racket modules. 
